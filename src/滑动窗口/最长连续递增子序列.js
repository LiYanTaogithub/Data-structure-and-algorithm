/**
 * 给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。

连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。

示例 1：


输入：nums = [1,3,5,4,7]
输出：3
解释：最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 
示例 2：


输入：nums = [2,2,2,2,2]
输出：1
解释：最长连续递增序列是 [2], 长度为1。
 */

/**
 * 思路分析：题目要求我们找的子序列是 连续 的，并且子序列里的元素要求 严格单调递增。在遍历的时候，从第 2 个元素开始；

如果当前遍历到的元素比它左边的那一个元素要严格大，「连续递增」的长度就加 1；
否则「连续递增」的起始位置就需要重新开始计算。
[i..j) 严格单调递增
 */

var findLengthOfLCIS = function(nums) {
  // i 记录递增的起始位置
  let len = nums.length, i = 0, j = 1, res = 0
  while(j < len) {
    if(nums[j - 1] >= nums[j]) {
      i = j // 不符合连续递增就右移递增的起始位置
    }
    j++
    res = Math.max(res, j - i)
  }
  console.log(res)
  return res
}

let nums = [1,3,5,4,7]
let nums2 = [2,2,2,2,2]
findLengthOfLCIS(nums2)

/**
 * 总结：区间不同的定义决定了不同的初始化逻辑、遍历过程中的逻辑。
 */