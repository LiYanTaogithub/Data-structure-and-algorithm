/**
 * 关键点：需要满足三个特征，最优子结构、无后效性和重复子问题。
 * 最优子结构：问题的最优解包含子问题的最优解。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解。后面阶段的状态可以通过前面阶段的状态推导出来。
 * 无后效性：有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。
 * 重复子问题：不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。
 * 动态规划和递归、分治没有本质的区别（关键看有无最优的子结构）
 * 共性：找到重复子问题
 * 差异性：最优子结构，中途可以淘汰掉次优结
 * 状态转移方程法的大致思路可以概括为，找最优子结构 - 写状态转移方程 - 将状态转移方程翻译成代码。
 */
/**
 * 解题散步曲：
 * 重复子问题是什么
 * 状态定义怎么定义
 * dp方程
 */
 # 初始化 base case
 dp[0][0][...] = base
 # 进行状态转移
 for 状态1 in 状态1的所有取值：
     for 状态2 in 状态2的所有取值：
         for ...
             dp[状态1][状态2][...] = 求最值(选择1，选择2...)

/**
 * 贪心、回溯、动态规划可以归为一类，而分治单独可以作为一类
 * 前三个算法解决问题的模型，都可以抽象成我们今天讲的那个多阶段决策最优解模型，而分治算法解决的问题尽管大部分也是最优解问题，但是，大部分都不能抽象成多阶段决策模型。
 * 回溯算法相当于穷举搜索。穷举所有的情况，然后对比得到最优解。不过，回溯算法的时间复杂度非常高，是指数级别的，只能用来解决小规模数据的问题。对于大规模数据的问题，用回溯算法解决的执行效率就很低了。
 * 贪心算法实际上是动态规划算法的一种特殊情况。它解决问题起来更加高效，代码实现也更加简洁。不过，它可以解决的问题也更加有限。它能解决的问题需要满足三个条件，最优子结构、无后效性和贪心选择性（这里我们不怎么强调重复子问题）。
 * 
 */